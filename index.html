<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2048</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Clear+Sans:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      --board-size: 500px;
      --cell-gap: 12px;
      --background: #faf8ef;
      --board: #bbada0;
      --empty: rgba(238, 228, 218, 0.35);
      --text-dark: #776e65;
      --text-light: #f9f6f2;
      --tile-2: #eee4da;
      --tile-4: #ede0c8;
      --tile-8: #f2b179;
      --tile-16: #f59563;
      --tile-32: #f67c5f;
      --tile-64: #f65e3b;
      --tile-128: #edcf72;
      --tile-256: #edcc61;
      --tile-512: #edc850;
      --tile-1024: #edc53f;
      --tile-2048: #edc22e;
      --tile-4096: #3c3a32;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Clear Sans", "Helvetica Neue", Arial, sans-serif;
      background: var(--background);
      color: var(--text-dark);
      display: flex;
      justify-content: center;
      min-height: 100vh;
    }

    .page {
      width: min(92vw, 540px);
      padding: 24px 0 48px;
    }

    .top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 16px;
    }

    h1 {
      margin: 0;
      font-size: 64px;
      line-height: 1;
    }

    .subtitle {
      margin: 8px 0 0;
      font-size: 16px;
    }

    .scoreboard {
      display: flex;
      gap: 12px;
    }

    .score-card {
      background: #bbada0;
      color: var(--text-light);
      border-radius: 4px;
      padding: 10px 16px;
      min-width: 80px;
      text-align: center;
    }

    .score-card .label {
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .score-card .value {
      display: block;
      font-size: 22px;
      font-weight: 700;
    }

    .controls {
      margin: 18px 0 12px;
      display: flex;
      gap: 12px;
    }

    .button {
      border: none;
      background: #8f7a66;
      color: #f9f6f2;
      font-weight: 700;
      padding: 10px 16px;
      border-radius: 4px;
      cursor: pointer;
    }

    .button.secondary {
      background: #bbada0;
    }

    .board-wrapper {
      position: relative;
    }

    .board {
      position: relative;
      width: var(--board-size);
      height: var(--board-size);
      background: var(--board);
      border-radius: 6px;
      padding: var(--cell-gap);
      margin: 0 auto;
      touch-action: none;
      box-shadow: inset 0 0 0 2px rgba(0, 0, 0, 0.04);
    }

    .grid {
      display: grid;
      grid-template-rows: repeat(4, 1fr);
      gap: var(--cell-gap);
      height: 100%;
    }

    .grid-row {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: var(--cell-gap);
    }

    .grid-cell {
      background: var(--empty);
      border-radius: 4px;
    }

    .tiles {
      position: absolute;
      inset: var(--cell-gap);
    }

    .tile {
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      width: calc((100% - 3 * var(--cell-gap)) / 4);
      height: calc((100% - 3 * var(--cell-gap)) / 4);
      border-radius: 4px;
      font-weight: 700;
      font-size: 34px;
      transition: transform 0.15s ease-in-out;
    }

    .tile.small {
      font-size: 28px;
    }

    .tile.tiny {
      font-size: 22px;
    }

    .message {
      position: absolute;
      inset: 0;
      background: rgba(238, 228, 218, 0.75);
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      z-index: 5;
      text-align: center;
      font-size: 32px;
      font-weight: 700;
      color: #776e65;
    }

    .footer {
      margin-top: 16px;
      font-size: 14px;
      line-height: 1.4;
    }

    @media (max-width: 640px) {
      :root {
        --board-size: min(88vw, 420px);
        --cell-gap: 10px;
      }

      h1 {
        font-size: 54px;
      }

      .score-card {
        min-width: 70px;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <header class="top">
      <div>
        <h1>2048</h1>
        <p class="subtitle">Join the numbers and get to the <strong>2048</strong> tile!</p>
      </div>
      <div class="scoreboard">
        <div class="score-card">
          <span class="label">SCORE</span>
          <span id="score" class="value">0</span>
        </div>
        <div class="score-card">
          <span class="label">BEST</span>
          <span id="best" class="value">0</span>
        </div>
      </div>
    </header>

    <section class="controls">
      <button id="new-game" class="button">New Game</button>
      <button id="keep-playing" class="button secondary" hidden>Keep Playing</button>
    </section>

    <section class="board-wrapper">
      <div id="game-message" class="message" hidden>
        <p id="message-text">Game over!</p>
        <button id="retry" class="button">Try again</button>
      </div>
      <div class="board" id="board">
        <div class="grid">
          <div class="grid-row">
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
          </div>
          <div class="grid-row">
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
          </div>
          <div class="grid-row">
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
          </div>
          <div class="grid-row">
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
          </div>
        </div>
        <div id="tiles" class="tiles"></div>
      </div>
    </section>

    <section class="footer">
      <p>Use your arrow keys or swipe to move the tiles. When two tiles with the same number touch, they merge into one!</p>
    </section>
  </div>

  <script>
    const BOARD_SIZE = 4;
    const STORAGE_KEY = "bestScore2048";

    const boardEl = document.getElementById("board");
    const tilesEl = document.getElementById("tiles");
    const scoreEl = document.getElementById("score");
    const bestEl = document.getElementById("best");
    const messageEl = document.getElementById("game-message");
    const messageTextEl = document.getElementById("message-text");
    const newGameBtn = document.getElementById("new-game");
    const retryBtn = document.getElementById("retry");
    const keepPlayingBtn = document.getElementById("keep-playing");

    let board = [];
    let score = 0;
    let bestScore = 0;
    let hasWon = false;
    let isGameOver = false;

    const tileColors = {
      2: "var(--tile-2)",
      4: "var(--tile-4)",
      8: "var(--tile-8)",
      16: "var(--tile-16)",
      32: "var(--tile-32)",
      64: "var(--tile-64)",
      128: "var(--tile-128)",
      256: "var(--tile-256)",
      512: "var(--tile-512)",
      1024: "var(--tile-1024)",
      2048: "var(--tile-2048)",
      4096: "var(--tile-4096)",
    };

    function init() {
      bestScore = Number(localStorage.getItem(STORAGE_KEY)) || 0;
      bestEl.textContent = bestScore;
      resetGame();
      attachEvents();
    }

    function resetGame() {
      board = createEmptyBoard();
      score = 0;
      hasWon = false;
      isGameOver = false;
      messageEl.hidden = true;
      keepPlayingBtn.hidden = true;
      addRandomTile();
      addRandomTile();
      updateScore(0);
      render();
    }

    function createEmptyBoard() {
      return Array.from({ length: BOARD_SIZE }, () =>
        Array.from({ length: BOARD_SIZE }, () => ({ value: 0, merged: false }))
      );
    }

    function addRandomTile() {
      const available = [];
      for (let r = 0; r < BOARD_SIZE; r += 1) {
        for (let c = 0; c < BOARD_SIZE; c += 1) {
          if (board[r][c].value === 0) {
            available.push({ r, c });
          }
        }
      }
      if (!available.length) return;
      const spot = available[Math.floor(Math.random() * available.length)];
      const value = Math.random() < 0.9 ? 2 : 4;
      board[spot.r][spot.c] = { value, merged: false };
    }

    function attachEvents() {
      window.addEventListener("keydown", handleKeyDown);
      newGameBtn.addEventListener("click", resetGame);
      retryBtn.addEventListener("click", resetGame);
      keepPlayingBtn.addEventListener("click", keepPlaying);

      let touchStart = null;
      boardEl.addEventListener("touchstart", (event) => {
        if (event.touches.length !== 1) return;
        touchStart = {
          x: event.touches[0].clientX,
          y: event.touches[0].clientY,
        };
      });

      boardEl.addEventListener("touchend", (event) => {
        if (!touchStart) return;
        const touch = event.changedTouches[0];
        const dx = touch.clientX - touchStart.x;
        const dy = touch.clientY - touchStart.y;
        const absX = Math.abs(dx);
        const absY = Math.abs(dy);
        if (Math.max(absX, absY) < 20) {
          touchStart = null;
          return;
        }
        if (absX > absY) {
          move(dx > 0 ? "right" : "left");
        } else {
          move(dy > 0 ? "down" : "up");
        }
        touchStart = null;
      });
    }

    function handleKeyDown(event) {
      const keyMap = {
        ArrowUp: "up",
        ArrowDown: "down",
        ArrowLeft: "left",
        ArrowRight: "right",
      };
      if (!keyMap[event.key]) return;
      event.preventDefault();
      move(keyMap[event.key]);
    }

    function move(direction) {
      if (isGameOver) return;
      clearMergedFlags();
      const moved = slideBoard(direction);
      if (!moved) return;
      addRandomTile();
      render();
      if (!hasMoves()) {
        endGame("Game over!");
      }
    }

    function clearMergedFlags() {
      for (let r = 0; r < BOARD_SIZE; r += 1) {
        for (let c = 0; c < BOARD_SIZE; c += 1) {
          board[r][c].merged = false;
        }
      }
    }

    function slideBoard(direction) {
      let moved = false;
      const vectors = {
        up: { r: -1, c: 0 },
        down: { r: 1, c: 0 },
        left: { r: 0, c: -1 },
        right: { r: 0, c: 1 },
      };
      const order = getTraversalOrder(direction);
      const vector = vectors[direction];

      order.forEach(({ r, c }) => {
        if (board[r][c].value === 0) return;
        let current = { r, c };
        let next = { r: r + vector.r, c: c + vector.c };
        while (withinBounds(next)) {
          const nextCell = board[next.r][next.c];
          const currentCell = board[current.r][current.c];
          if (nextCell.value === 0) {
            board[next.r][next.c] = { ...currentCell };
            board[current.r][current.c] = { value: 0, merged: false };
            current = { ...next };
            next = { r: current.r + vector.r, c: current.c + vector.c };
            moved = true;
          } else if (nextCell.value === currentCell.value && !nextCell.merged && !currentCell.merged) {
            const newValue = nextCell.value + currentCell.value;
            board[next.r][next.c] = { value: newValue, merged: true };
            board[current.r][current.c] = { value: 0, merged: false };
            updateScore(newValue);
            moved = true;
            if (newValue === 2048 && !hasWon) {
              hasWon = true;
              showWin();
            }
            break;
          } else {
            break;
          }
        }
      });

      return moved;
    }

    function getTraversalOrder(direction) {
      const order = [];
      const rows = [...Array(BOARD_SIZE).keys()];
      const cols = [...Array(BOARD_SIZE).keys()];
      if (direction === "down") rows.reverse();
      if (direction === "right") cols.reverse();
      for (const r of rows) {
        for (const c of cols) {
          order.push({ r, c });
        }
      }
      return order;
    }

    function withinBounds({ r, c }) {
      return r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE;
    }

    function updateScore(amount) {
      score += amount;
      scoreEl.textContent = score;
      if (score > bestScore) {
        bestScore = score;
        bestEl.textContent = bestScore;
        localStorage.setItem(STORAGE_KEY, String(bestScore));
      }
    }

    function render() {
      tilesEl.innerHTML = "";
      for (let r = 0; r < BOARD_SIZE; r += 1) {
        for (let c = 0; c < BOARD_SIZE; c += 1) {
          const value = board[r][c].value;
          if (value === 0) continue;
          const tile = document.createElement("div");
          tile.className = "tile";
          tile.style.transform = `translate(${positionFor(c)}, ${positionFor(r)})`;
          tile.style.background = tileColors[value] || "#3c3a32";
          tile.style.color = value <= 4 ? "#776e65" : "#f9f6f2";
          tile.textContent = value;
          if (value >= 128 && value < 1024) {
            tile.classList.add("small");
          } else if (value >= 1024) {
            tile.classList.add("tiny");
          }
          tilesEl.appendChild(tile);
        }
      }
    }

    function positionFor(index) {
      const cellSize = tilesEl.clientWidth / 4;
      const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--cell-gap"));
      return `${index * cellSize + index * gap}px`;
    }

    function hasMoves() {
      for (let r = 0; r < BOARD_SIZE; r += 1) {
        for (let c = 0; c < BOARD_SIZE; c += 1) {
          const value = board[r][c].value;
          if (value === 0) return true;
          const neighbors = [
            { r: r + 1, c },
            { r: r - 1, c },
            { r, c: c + 1 },
            { r, c: c - 1 },
          ];
          for (const { r: nr, c: nc } of neighbors) {
            if (withinBounds({ r: nr, c: nc }) && board[nr][nc].value === value) {
              return true;
            }
          }
        }
      }
      return false;
    }

    function endGame(message) {
      isGameOver = true;
      messageTextEl.textContent = message;
      messageEl.hidden = false;
    }

    function showWin() {
      messageTextEl.textContent = "You win!";
      messageEl.hidden = false;
      keepPlayingBtn.hidden = false;
    }

    function keepPlaying() {
      messageEl.hidden = true;
      keepPlayingBtn.hidden = true;
      isGameOver = false;
    }

    init();
  </script>
</body>
</html>
